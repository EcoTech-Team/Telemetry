/*                                                          *
*   spi_controller.c                                        *
*                                                           *
*   Author: Cezary Sobczak https://github.com/Cezarus27     *
*   Date:   04.09.2020                                      *
*   Reference article: elm-chan.org/docs/mmc/mmc_e.html     *
*                                                           */

#define TRUE  1
#define FALSE 0
#define bool BYTE

#include "stm32f1xx_hal.h"

#include "diskio.h"
#include "spi_controller.h"

extern SPI_HandleTypeDef hspi1;
extern volatile uint8_t Timer1, Timer2;

#define SD_CS_GPIO_Port GPIOA
#define SD_CS_Pin GPIO_PIN_4

static uint8_t PowerFlag = 0;

/* SPI Chip Select */
static void SELECT(void)
{
  HAL_GPIO_WritePin(SD_CS_GPIO_Port, SD_CS_Pin, GPIO_PIN_RESET);
}

/* SPI Chip Deselect */
static void DESELECT(void)
{
  HAL_GPIO_WritePin(SD_CS_GPIO_Port, SD_CS_Pin, GPIO_PIN_SET);
}

static void SPI_Write_Byte(BYTE *data)
{
  /* Try to transmit data byte until SPI get into STATE_READY state */
  while(HAL_SPI_GetState(&hspi1) != HAL_SPI_STATE_READY)
  HAL_SPI_Transmit(&hspi1, data, 1, SPI_TIMEOUT);
}

/*
Because the data transfer is driven by serial clock generated by host
controller, the host controller must continue to read data, send a 0xFF and get
received byte, until a valid response is detected. The MOSI signal must be kept
high during read transfer (send a 0xFF and get the received data)
*/
static uint8_t SPI_Read_Byte(void)
{
  uint8_t data = 0;
  uint8_t dummy_data = 0xFF;

  while(HAL_SPI_GetState(&hspi1) != HAL_SPI_STATE_READY)
  HAL_SPI_TransmitReceive(&hspi1, &dummy_data, &data, 1, SPI_TIMEOUT);

  return data;
}

/*
Some commands take a time longer than NCR and it responds R1b. It is an R1
response followed by busy flag (MISO is driven to low as long as internal
process is in progress). The host controller should wait for end of the process
until MISO goes high (a 0xFF is received). If received data is not a R1b and
time is over, return last received byte.
*/
static uint8_t SPI_Wait_Ready(void)
{
  uint8_t data = 0;
  Timer2 = 50;  // 500ms

  do data = SPI_Read_Byte();
  while (data != 0xFF && Timer2);
  return data;
}

static void Power_ON(void)
{
  BYTE frame_arg[6];
  uint32_t counter = 4096;
  // CS line to high
  DESELECT();

  // wait 80 clock pulses and set MOSI high
  for(int i=0; i < 10; i++)
    // send 8 bytes: 8 * 10 = 80 cycles
    SPI_Write_Byte(0xFF);

  // CS line to low
  SELECT();

  // command frame has 42bytes
  frame_arg[0] = CMD0;
  frame_arg[1] = 0;
  frame_arg[2] = 0;
  frame_arg[3] = 0;
  frame_arg[4] = 0;
  frame_arg[5] = 0x95;

  for(int i=0; i < 6; i++)
  SPI_Write_Byte(frame_arg[i]);

  // Wait for R1 with IN_IDLE_STATE flag set
  while(SPI_Read_Byte() != 0x01 && counter)
    counter--;

  DESELECT();
  SPI_Write_Byte(0xFF);

  PowerFlag = 1;
}

static void SPI_SendCMD(BYTE cmd, DWORD arg)
{
  BYTE frame_arg[6];
  BYTE crc;
  // CS line to low
  SELECT();

  if (cmd = CMD0)
    crc = 0x95;
  else if(cmd = CMD8)
    crc = 0x87;
  else
    crc = 0;

  // command frame has 42bytes
  frame_arg[0] = cmd;
  frame_arg[1] = ((BYTE) (arg >> 24));  /* Argument[31..24] */
  frame_arg[2] = ((BYTE) (arg >> 16));  /* Argument[23..16] */
  frame_arg[3] = ((BYTE) (arg >> 8));   /* Argument[15...8] */
  frame_arg[4] = ((BYTE) arg);          /* Argument[7....0] */
  frame_arg[5] = crc;

  for(int i=0; i < 6; i++)
  SPI_Write_Byte(frame_arg[i]);

}
/*
*  Execute from user_diskio.c
*/
DSTATUS SD_disk_initialize(BYTE pdrv)
{
  WORD buff = 0;
  Timer1 = 100;       // 1000ms
  if (PowerFlag == 0)
    Power_ON();
  else
  {
    SPI_SendCMD(CMD0, 0);

    while(1)
    {
      if(SPI_Read_Byte() == 0x01)
      {
        /* Card is SDC Ver.2+ */
        SPI_SendCMD(CMD8, 0x1AA);
        for(int i=0; i < 5; i++)
        {
          if (i == 0 && SPI_Read_Byte() == 0x05) // Error: illegal CMD
          {
            buff = 0x05;
            break;
          }

          if (i == 3)
            buff = (SPI_Read_Byte() << 8);
          else if (i == 4)
            buff = SPI_Read_Byte();
        }

        if (buff == 0x1AA)
        {
          BYTE resp;
          do
          {
            SPI_SendCMD(CMD41, 0x40000000);
            resp = SPI_Read_Byte();
          }
          while(resp == 0x01 && Timer1);

          if (resp == 0x00)
            SPI_SendCMD(CMD58, 0);
        }
        else if (buff == 0x05)
        {
          /* Card is SDC Ver.1 */
          BYTE resp;
          do
          {
            SPI_SendCMD(CMD41, 0);
            resp = SPI_Read_Byte();
          }
          while(resp == 0x01 && Timer1);

          if (resp == 0x00)
            SPI_SendCMD(CMD16, 0x200);
          //else if (resp == 0x05) // Idk if it is necessary
        }
      }
      else
      {
        /* Unknown card. Run Power OFF */
      }
    }
  }
}
